Race Condition (경합조건) 
=====
- 쓰레드들이 순서를 지키지 않고 동시다발적으로 경합을 벌이면서 실행
- num++ 을 10000번 하는 쓰레드와, num-- 을 10000번 하는 쓰레드를 동시에 동작시키면 원하는 결과(0)이 나오지 않을 수 있다.
- 이는 numm++ 은 우리 눈에는 한줄의 코드로 보이지만 사실 3줄로 구성되어 있기 때문이다.
```C
// num++
int temp = number;
temp += 1;
number = temp;
```
- num-- 도 마찬가지로 3줄의 코드로 구성되어 있고, 이는 num++ 을 하고 num-- 하는것이 아닌, 한쪽은 number 를 가져와서 temp 에 저장하고 1을 올리면서 다른 한쪽은 같은 number 를 가져와서 temp 에 저장하고... 서로 원하지 않는 값을 이용하게 되는것이다.
- 이때문에 원자성(Atomic) 을 지켜서 작성해야 위와 같은 문제가 발생하지 않는다.

### Atomic (원자성)
- 쪼개질 수 없는 코드
- 어떠한 동작이 한번에 일어나야 한다.
- 예를 들어 골드를 100 지불하고 아이템을 얻는다고 할 때, 동시에 동작하지 않으면 두 행동 사이에 간섭(오류 등)될 수 있기 때문에 골드만 빠져 나가고 아이템이 안들어 온다는 등의 문제가 발생할 수 있다.

### Interlocked
- 위와 같은 현상을 Interlocked 을 사용하여 해결할 수 있다.
```C
Interlocked.Increment(ref num) // 증가
Interlocked.Decrement(ref num) // 감소
```
- 위 두 함수는 반환 타입이 int 형 인데, 이는 증가시킨 값을 확인하기 위해 사용한다.
- 증가시킨 값을 확인하기 위해 다음 라인에 코드를 작성하면 원자성을 지키지 않았기 때문에(다른 쓰레드에서 사용될 수 있다) 다른 값을 읽어오게 되기 떄문에 반환형을 이용하는 것이 확실한 값이다.

Lock
=====
- Muutal Exclusvie(상호배제)를 시켜준다. 이 말은 즉, 다른 쓰레드의 접근을 막아준다는 의미다.
- Interlock 의 단점은 변수만 가능하다는 것인데, Lock 을 사용하여 해당 코드들에서 다른 쓰레드의 접근을 막아준다(싱글 쓰레드화 시켜준다).
```C
Monitor.Enter(obj)
number++
Monitor.Exit(obj)
```

### DeadLock
- Lock 을 해제하지 않고 return을 하게 되면 다른 쓰레드에게 열리지 않고 return 하게 되어 하염없이 기다리게 된다. 이를 DeadLock 이라 한다.
```C
Monitor.Enter(obj)
number++
return;
Monitor.Exit(obj)
```
- c# 에는 Lock 클래스가 구현되어 있기때문에 다음과 같이 해결할 수 있다.
```C
lock(obj)
{
  num++;
}
```
- 그럼에도 예기치 못한 예외가 발생할 수 있는데, try-finally 문을 이용하여 finally 에서 해제하기 할 수 있다. 하지만 매번 그렇게 처리하면 번거롭다.
- 또한, 규약을 정하여 잠구는데 순서를 정의할 수도 있다(1번을 잠궈야만 2번을 잠굴수 있다던지)

### DeadLock 의 궁극적인 해결법
- 잘 생각해보면 일반적으로 코드에 오류가 발생할 것을 예상하여 try-catch 문을 사용하여 처리하는 코드를 늘리기 보단, 일부러 충돌을 발생시켜 오류를 고치는 것이 현명하다.
- 같은 이유로 Lock 을 가지는데 시간이 지나면 포기하도록 코드를 작성하거나 try-finally 문을 사용하여도 되지만
- Deadlock 이 발생한 경우는 대부분 Lock 구조에 문제가 있는 것이기 때문에 이중으로 오류를 처리하는 코드를 작성하는 것 보다 문제가 있는 부분을 수정하는 것이 현명하다.
- Deadlock 은 개발중일때보다 Live 상태에서 많이 발생하는데 시간이 조금만 어긋나도 정상작동을 하기 때문이다.
