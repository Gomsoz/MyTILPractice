변수의 수직 유효 범위
-----
### 변수가 처음 생성되고 소멸할 때 까지의 코드상에서의 수직 범위
+ 변수의 범위는 좁을수록 좋다. 범위가 넓은수록 버그 발생 가능성이 높아지고, 코드를 보기 어려워진다.
+ 함수가 길어질수록 변수의 유효범위가 넓어지는 경우가 많다. -> 함수의 길이를 되도록 짧게하자.

### try 블록의 범위는 좁을수록 좋다.
+ 가급적 예외가 발생할 지점만 감싸는 것이 좋다.
+ try문을 함수 전체로 한다던지 커지게 되면 가독성도 떨어지고, 올바르게 예외처리를 할 기회도 날아갈 수 있다.
+ try문을 길게 설정하여 의도치 않은 부분에서 예외가 던져질 경우가 생길 수 있다. 

if절 안의 코드는 딱 한 줄만
-----
+ 중괄호 안의 복잡한 코드들을 밖으로 빼내어 함수로 정의하고 호출하여 중괄호 중첩을 피할 수 있다.
+ try문도 비슷하게 try문 안의 함수들을 밖으로 빼내어 사용하면 좋다.

무분별한 임시 변수 사용
-----
+ 무분별하게 임시 변수를 사용하면 가독성이 떨어진다.
```C
string temp = Func();
return temp;
```
+ return Func(); 해도 되는 코드지만 무분별하게 temp변수를 사용했다.
+ 임시변수는 가독성을 향상시킬 수 있는 경우에만 사용하는 것이 좋다.
+ 가급적이면 'temp'라는 이름은 피하는 것이 좋다.

쿼리와 명령 분리
-----
### 쿼리: 시스템 상태의 변화를 일으키지 않고 결괏값을 반환
### 명령: 시스템 상태를 변경   
### 함수는 쿼리와 명령 둘 중 하나여야만 한다.
+ 쿼리와 명령을 동시에 가지는 함수가 있다면, 그 함수의 호출자는 쿼리를 마음 편하게 호출 할 수 없을 것이다.   

수정말고 반환하라
-----
### 수정되는 데이터는 추적에 용이해야한다.
+ 변수를 직접 수정하지 않고, 함수가 수정되는 값을 반환하도록 하면 수정된 값을 추적하기 용이해진다.
```C
int totalUsedPoints = 0;
calculateTotalUsedPoint();

void calculateTotalUsedPoint(){
    for(Integer usedPoint : pointUsedHistories)
        totalUsedPoints += usedPoint; 함수내에서 필드에 직접 값을 대입
}
```
```C
int totalUsedPoints = calculateTotalUsedPoint(); 값을 반환하여 대입

int calculateTotalUsedPoint(){
    int totalUsedPoints = 0;

    for(UsedPoint point : usedPoints)
        totalUsedPoints += point.amount();

    return totalUsedPoints;
}
```

Tell, Don't ask
-----
+ 객체의 내부상태를 ask 하지말고 tell 해야 한다.
+ 객체 내부에 직접 접근하여 값을 요청하지말고 함수를 통하여 필요한 행동을 말해야한다.
```C
function moveElevator(int floorNumber) {
    if(elevator.currentFloor == floorNumber) 객체 내부에 접근하여 값을 가져와서 비교한다.
        return;                              이경우에 객체 내부 상태가 변경되면 이부분도 변경되야 한다.

    elevator.move(floorNumber);
    elevator.currentFloor = floorNumber;
}
```
```C
class Elevator{
    private integer currentFloor;

    function move(int floorNumber){
        if(currentFloor == floorNumber)
            return;

        moveInternal()

        this.currentFloor = floorNumber
    }
}

class ElevatorManager{
    private Elevator elevator;

    function moveElevator(int floorNumber){
        elevator.move(floorNumber); 함수를 호출만 할뿐, 객체 내부에 관여하지않는다.
    }                               객체 내부가 변경되더라도 신경 쓸 필요가 없다. -> 캡슐화가 잘 되어있다.
}
```

null 반환
-----
+ null을 반환하는 함수는 가급적 만들지 않는 것이 좋다.
+ 예상치 못한 예외가 발생할 수 있다(NullPointerException).
+ null을 반환하는 함수를 호출할 경우에 null검사는 꼭 해주어야한다.
+ 값이 없음을 표현하고 싶은데 null 반환을 피하고자 한다면 null object반환을 고려해본다.   
null object를 반환하면 호출하는 코드에서 null검사를 하지않아 발생하는 null관련 예외나 버그가 발생하는 경우를 줄어들게 한다.

### 값이 없을 때 빈 배열이나 빈 컬렉션을 반환하는 것을 고려해볼 수 있다.
+ 빈배열, 빈컬렉션, 널오브젝트 같이 재사용이 가능한 것들은 이미 존재하는 객체를 사용하는 것이 좋다.   
매번 만들지 말고, 여러곳에서 사용해도 문제가 없으면 싱글턴 오브젝트로 만들어 놓고 사용하는 것을 고려해 볼 수 있다.

### Optional
+ 자바언어에서 사용하는..... 추후에 자바를 배우면 추가 할 필요가 있음.

if-else
-----
### if-else문은 가독성이 매우 안좋다.
+ 우선적으로 else문을 사용하지 않고 코드를 작성할 수 있는지 고민해본다.
+ if절에서 조건을 검사하고 리턴을 하거나 예외를 던지도록 하면 else문을 줄일 수 있다. _(조건 검사에만 쓰라는 소리같다...)_
+ else문을 없애기 어려운 상황이라면, if절에는 정상적인 상황에 대한 조건을 두고, else문에는 비정상적인 상황을 두는 것이 직관상 좋다.

무의식적인 하드코딩
-----
+ if(category == "S001") 같이 문자열상수, 인트타입 상수는 하드코딩을 하도록 유발한다.
+ 위와같이 하드코딩을 하는 것보다. isSneakers(variable) 로 캡슐화를 하거나, enum타입을 사용하는 편이 좋다.

문맥
----
### 객체가 갖는 값(상태)와 이를 처리하는 로직(행위)은 한 곳에서 관리 되어야 좋다.
+ 객체의 값이 먼 거리에 있는 곳에서 로직을 처리하면, 코드를 수정할 때, 여러개의 클래스를 수정해야 한다.(캡슐화)

### 일급컬렉션
+ 컬렉션을 포함한 클래스에는 반드시 컬렉션 외의 다른 멤버 변수가 없어야 한다. _(이해가 안되는 내용 추가 설명 필요한 듯)_

### 상태와 행위를 enum안에 담을 수 있다.

### 원시타입을 지양하라
+ 핸드폰 번호를 저장한다고 했을 때, __string phoneNumber = "01012345678"__ 이렇게 저장하고,   
국번의 정보를 알려면 해당 문자열의 앞 3글자를 파싱해야한다. 문자열을 저장한 값과, 파싱하는 로직이 분리가 되어있다.
+ 위의 경우 클래스를 만들어서 번호, 국번(내부함수에서 파싱)을 가지고 있게 하면 상태와 로직이 함께 담기게 된다. 

배열의 표현력
-----
### 명시적인 표현이 필요한 곳에 배열이나 리스트를 사용하지 말아야 한다.
+ 배열 get에 0번에는 이름 1번은 메일주소 2번은 권한을 나타낸다고 하면,   
배열과 인덱스 사이에는 연관성이 없기 때문에 다른 문서나, 주석을 봐야지 알 수 있게된다.   
또한 주석이나 이를 설명하는 문서는 코드가 수정되었다고 해서 항상 최신으로 유지된다는 보장이 없기 때문에 신뢰도가 떨어진다.
+ 추상화를 유지하도록 user.GetUserName(); 이런식으로 표현하면 혼란을 줄일 수 있다.

하나의 개념, 하나의 상태
-----
### 하나의 개념엔 하나의 상태만 들어가야 혼란이 없다
+ 다른 성격의 내용을 타입이 같다는 이유로 동일한 컬렉션에 넣거나,    
두 가지 이상의 상태를 한 변수에 담는 경우 혼란을 줄 수 있다.

Don't reinvent the wheel
-----
### 이미 개발된 기능을 다시 만드는데 시간을 사용하지 않아야 한다.
+ 사용하는 언어, 라이브러리, 프레임워크에서 제공하는 유틸성 함수들을 잘 확인하여   
이미 있는 기능을 다시 만드는 데 시간을 허비하면 안된다.

기술의 의도
-----
+ 프레임워크를 사용하다보면 어떤 목적을 위해 사용가능한 방법이 여러가지인 경우가 있는데,   
이럴때 사용하려는 방법의 의도를 고려하여 더 적합한지 파악하는 것이 중요하다.

관례
-----
### 협업이 중요하다
+ 프레임워크를 사용하면서 동료들과 다른방식으로 개발하려 하지 않아야한다.   
서로간의 약속을 지키면서 프레임워크의 기능들을 의도된 방식으로 사용하여야 동료들의 혼란을 줄일 수 있다.

정적 팩토리 메서드
-----
+ _추후에 따로 문서를 만들 필요가 있을 것 같다._

다형성은 만병통치약이 아니다
-----
### 다형성이 언제나 옳은것이 아니다.
+ 인터페이스를 구현한 클래스가 3개 있을 때, 인터페이스가 변경되면 3개의 클래스가 모두 변경되어야 한다.
+ 변경이 어디서 이루어지느냐에 따라서 절차지향적(if,swith)이냐 다형성이냐를 따져볼 수 있다.
+ 인터페이스를 구현한 클래스가 추가될 가능성이 큰지, 인터페이스에 새로운 함수가 추가될 가능성이 큰지 따져볼 수 있다.   
_(이해가 잘 안되는 내용, 구체적인 예시를 찾아볼 필요가 있어보인다.)_

YAGNI(You aren't gonna need it)
-----
### 클래스나 함수는 실제로 필요할 때 만드는 것이 좋다.
+ 초보 개발자들은 객체지향, 디자인패턴을 처음 접할 때, 무리하게 확장성을 고려하여 쓰지도 않을 클래스나 함수를 만드는 경향이 있다.
+ 실제 개발중엔 설계 변경이나, 요구사항이 자주 변경되기 때문에 미리 만들어봐야 헛수고인 경우가 많다.
+ 현재에 맞추어서 개발을 해야 올바르게 갈 가능성이 높다고 한다.
+ 미리 만들어 두었던 내용이 설계가 변경되어 적절하게 수정이 되지 않는다고 하면, 버그의 원인이 될 수 있다.
+ 공개 api에 포함되어 있다면, 이를 사용하고 있는 클라이언트 코드가 있으면 없애기가 곤란하기 때문에 필요할 때 만들어야 한다

### 그렇다고 변화에 대응할 필요가 없다는 것은 아니다.
+ 설계가 바뀔 수 있음을 고려하되, 구체적으로 당장 설계에 담지 말라는 것이다.
+ 결국 미래에 설계가 바뀔 수 있음을 고려한 개발이란 무엇을 의미하는 것인가 하면   
여러 클린코드 작성법, SRR, DIP 객체지향 개발 원칙을 바탕으로 설계, 개발하는 것이다.   
원칙을 지켜서 개발을 한다면 나중에 변경이 필요하더라도 유연하게 대처할 수 있다.

Rule of Three
-----
### 보통 중복코드가 3개이상 발견될 때 리펙토링을 하는 것이 좋다.
+ 여러 리팩토링 기법과 디자인 패턴같은 설계 기법들은 중복코드를 피하기 위해 개발되었다.   
중복된 코드가 많을 수록 변경할 내용이 많아지기 때문에 유지보수에 좋지 않기 때문이다.
+ 중복코드가 한두개 정도일 때 섣불리 리팩토링을 진행하면 잘못된 설계의 원인이 될 수 있다.   
개발중엔 설계변경, 요구사항등이 변경이 잦기 때문이다.
+ __Duplication is far cheaper than the wrong abstraction__   

### 코드에서 중복된 내용을 뽑아내기 힘든 경우 허용하는게 나을 수 있다.
+ 애매하게 중복 코드를 없애려고 한다면, 오히려 코드가 복잡하게 될 수 있다.
+ 중복코드를 해결하는 것보다, 코드의 단순함, 명료성이 중요할 때가 있다.   
_(결국 중복코드를 제거하는 것은 유지보수와 코드가 깔끔해지는 걸 원하기 때문에 부합하지 않으면 추천하지 않는 것 같다.)_

### 중복 코드를 제거할 때 복사 붙여넣기를 주의하라
+ 중복 코드를 제거하기 위해 공통 코드를 뽑아내려 하다보면 중복이 아닌 내용까지 복사되는 경우가 있다.   
이를 주의해서 복사 붙여넣기를 사용하여야 한다.
