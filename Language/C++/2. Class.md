 Class (클래스)
 =====
 ### 클래스는 객체를 표현하게 해준다.
 + C에서 __struct__ 는 단순히 변수들의 집합이라면, __class__ 는 구조체에 멤버함수가 추가되었다.   
 (멤버변수 + 멤버함수)
 + 멤버변수에 종속된 멤버함수들을 하나로 묶으면서 구현과 관리가 용이해졌다.
 + 멤버변수, 함수를 통해 모든 사물들의 데이터(변수)와 기능(함수)들을 모을 수 있게 되었다.(객체화)
 + 어디서든 접근이 가능한 struct와 다르게 class는 접근제어지시자를 통해 제한적인 접근을 하게 해준다.
 ### 접근제어지시자
 + private : 외부로부터 접근 금지
 + protected : 상속되는 자식클래스만의 접근 허용
 + public : 어디든 접근 가능
 
 ### information hiding (정보 은닉)
 -----
 + 멤버변수를 private로 선언하여 외부로부터 접근을 막고,   
 안전한 방법(생성자 이용)을 통해 멤버변수에 접근하게 한다.
 
 ### Capsulation (캡슐화)
 + 하나의 목적을 가진 클래스에 연관된 것들을 넣는 것.
 + 캡슐화가 잘 되어있지 않을 경우에, 각 __class__ 간의 독립성이 떨어져서   
 하나의 __class__ 가 수정이 되면 연관되어 있는 __class__ 들을 수정해야 하는 경우가 발생함.
 + 캡슐화가 잘 되어있으면 여러개의 __class__ 수정해도 되지않기 때문에, 유지보수가 용이해짐.
 
 ### Conductor (생성자)
 + 객체 생성시에 딱 한번 호출되는 함수. 멤버변수를 초기화 할 때 사용한다.
 + 반환형이 없고, class의 이름과 같다.
 + 생성자를 정의하지 않은 경우, 디폴트 생성자가 호출된다.
```C
public class simpelClass
class Simple
{
  private:
    int a;
  public:
    Simple();
    Simple(int value);
};
Simple::Simple()
{
  a = 1;  
}
Simple::Simple(int value)
{
  a = value;
}
```
### Initializer (이니셜라이저)
+ 생성자의 호출과 동시에 초기화를 시킨다.
+ 객체로 선언된 멤버변수의 초기화를 위한 생성자 호출에 사용된다.
```C
class Class1
{
  private:
    int a;
    int b;
}

class Class2
{
  private:
    Class1 class1;
  public:
    Class2(int a2, int b2) : class1(a2, b2)
    {
      ...
    }
}
```

### Destructor (소멸자)
+ 동적할당된 메모리영역을 소멸할 때 사용된다.
+ 소멸자는 객체에 하나만 존재한다. 보통은 소멸자를 선언하지 않음.
+ 소멸자는 생성자의 역순으로 소멸된다.
+ __~class();__

### this
+ 객체 자신의 주소값을 가리킨다.

### Copy Constructor (복사 생성자)
+ 새로운 객체를 기존의 객체로 대입연산을 할 때 호출되는 생성자.
  ### Default Copy Constructor (디폴트 복사 생성자)
    + 별도의 정의가 없으면 디폴트 복사 생성자가 호출된다.
    + 단순히 멤버 대 멤버로 복사를 하기 때문에 두개의 객체가 하나의 데이터를 참조하게 된다(얕은 복사)
    + 이때 소멸자가 호출되면 한 객체의 소멸자가 진행되어 데이터가 사라지지만,   
    복사를 한 다른 객체는 소멸이 되기전에 데이터가 사라진 상태에서 소멸자가 호출되므로 문제가 발생한다.
    + 위의 문제점 때문에 별도의 복사생성자를 정의하여 깊은 복사를 진행해야 한다.   
    깊은 복사는 데이터까지 복사하기 때문이다.
    
  ### 복사 생성자가 호출되는 시점
    + 기존에 생성된 객체를 이용해 새로운 객체를 초기화 하는 경우.
    + call-by-reference 호출방식에서 객체를 인자로 전달하는 경우.
    + 객체를 반환하되 참조형으로 반환하지 않는 경우.
    ```C
      Person(const Person &copy) : age(copy.age)
      {
        name = new char[strlen(copy.name + 1];
        strcpy(name, copy.name) 문자열 복사
      }
    ```
### static 멤버 변수 (클래스 변수)
+ 객체 생성 유무와 관계없이 딱 하나만 메모리에 생성되며,   
해당 클래스의 객체들이 모두 참조가 가능하다.
+ static 멤버 함수
+ const static 멤버 변수
### friend
+ 선언한 클래스 함수는 선언한 클래스의 private 변수에 접근이 가능하다.
