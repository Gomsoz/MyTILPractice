Sort (정렬)
=====
+ 데이터를 일정한 규칙에 따라서 재배열 하는 것.

Bouble Sort (버블 정렬)
=====
### 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식.
+ 앞의 두 데이터를 계속 비교하며 위치를 바꾸어 나감.

### 성능평가 (데이터 수가 n개 일 때, 발생하는 비교연산, 이동연산)
+ n-1 + n-2 + n-3 ... +2 + 1
+ 비교연산, 이동연산 : T(n) = O(n<sup>2</sup>)

Selection Sort (선택 정렬)
=====
### 가장 작은 데이터를 찾아서 가장 앞의 데이터와 교환하는 방식.

### 성능평가
+ n-1 +n-2 +n-3 ... +2 +1
+ 비교연산 : T(n) = O(n<sup>2</sup>)
+ 이동연산 : T(n) = O(n)
+ 선택정렬과 버블정렬을 비교했을때, 선택정렬의 이동연산이 n번 일어나므로 선택정렬이 더 좋아보일 수 있다.   
그러나 선택정렬은 무조건 비교연산을 진행해야 하지만, 버블정렬은 비교연산이 일어나지 않을 수도 있다.
+ 위와 같은 이유로 두 정렬을 비교하는 것은 무의미하다.

Insertion Sort (삽입 정렬)
=====
+ 정렬이된 영역과 정렬이 완료된 영역을 구분하여,   
차례대로 정렬이 완료된 영역에 위치에 맞게 삽입시킨다.

### 성능평가
+ 1 + 2 + 3 ... + n-2 + n-1
+ O(n<sup>2</sup>)

Heap Sort (힙 정렬)
=====
### 데이터들을 완전 이진 트리(힙)로 구성하여 정령하는 방식.

### 성능평가
+ 시간복잡도 : T(n) = O(nlogn)
+ 공간복잡도 : T(n) = O(n)

Merge Sort (병합 정렬, 합병 정렬)
=====
### "divide and conquer" 이라는 알고리즘 디자인 기법에 근거한 정렬법.
+ 분할 -> 정복 -> 결합
+ 데이터가 하나가 될 때까지 분할을 한 다음, 다시 병합하면서 정렬한다.
### 병합 구현
+ 앞부분(F)과 뒷부분(R)을 나누어서 비교하여 저장한다.
1. F의 1번과 R의 1번을 비교하여 저장하고 저장한 데이터의 인덱스를 하나 올린다.
2. F의 1번의 데이터가 저장되었으면, F의 2번과 R의 1번을 다시 비교한다.
3. F의 2번과 R의 2번, F의 2번과 R의 3번... 이런식으로 앞부분과 뒷부분의 데이터를 하나씩 비교하여 저장한다.
4. 위 과정을 반복하고 남은 배열을 한번에 넣어주면 된다.

### 성능평가
+ T(n) = O(nlogn)

Quick Sort (퀵 정렬)
=====
+ 기준키를 기준으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 지닌 데이터는 뒤로 가도록 하여,   
작은 값을 갖는 데이터와큰 값을 갖는 데이터로 분리해가며 정렬하는 방법.
+ 대체적으로 많이 사용하는 방법. 재귀적 특성을 지닌다.
### 원리
1. 다섯가지 변수를 가진다.
  + left : 정렬대상의 가장 왼쪽
  + right : 정렬대상의 가장 오른쪽
  + pivot : 중심점, 중심축
  + low : 피벗을 제외하고 가장 왼쪽
  + high : 피벗을 제외하고 가장 오른쪽
2. pivot 설정
  + 데이터의 맨 앞을 pivot으로 설정한다.
3. hight와 low의 이동 (pivot을 기준으로 우선순위에 따라 이동)
  + low를 pivot보다 큰 데이터를 만날 때 까지 오른쪽으로 이동한다.
  + high를 pivot보다 작은 데이터를 만날 때 까지 왼쪽으로 이동한다.
4. high와 low의 교환
  + high와 low의 데이터를 교환하고, high와 low가 역전 될 때까지   
  low는 오른쪽으로, high는 왼쪽으로 이동하면서 교환을 반복한다.
5. pivot을 이동시킴
  + high와 low가 역전되면 왼쪽에는 pivot을 기준으로 우선순위가 높은 데이터가, 왼쪽에는 낮은 데이터가 정렬된다.
  + 이후에 pivot을 사이에 넣어준다.
6. left > right가 될 때 까지 반복한다. -> 더이상 나눌수가 없음을 의미한다.
### 구현시 주의점
1. 경계검사가 구현시에 헷갈릴 수 있다.
```C
while (low <= high)
{
  while(pivot > arr[low])
    low++;
  while(pivot < arr[high])
    high--;
}
```
+ 위와 같은 코드는 [3,3,3]인 배열일 경우 pivot = arr[low] = arr[high] 기 때문에 low와 high변화가 없어서 교차가 불가능 하다.
+ 경계검사는 아래와 같이 수정이 필요하다.
```C
  while(pivot >= arr[low] && low <= right)
    low++;
  while(pivot <= arr[high] && high >= left + 1)
    high--;
```
2. 피벗은 가급적 중간값으로 설정되어야 최상의 성능을 보인다.
  + 피벗이 가장 낮거나 높으면 피벗 재설정의 횟수가 증가한다.
### 성능 평가
+ 최선의 경우(pivot이 정확히 가운데 값인 경우)
  + T(n) = O(nlogn)
+ 최악의 경우 (완전히 정렬된 된 상태인 경우)
  + T(n) = O(n<sup>2</sup>)

Radix Sort (기수 정렬)
=====
### 특징
+ 정렬순서의 앞서고 뒤짐을 비교하지 않는다.
+ T(n) = O(nlogn)을 뛰어넘을 수 있다.
+ 적용범위가 제한적이다. -> 길이가 동일한 데이터들의 대상으로 정렬이 용이하다.
### 원리
+ LSD(Least Significant Digit) 방식
  1. 아랫자리부터 비교하는 방식
  2. 숫자가 4까지 있기 때문에 버킷을 5개 준비한다 (0~4)
  3. 기준(자리수를 올려간다)을 바꿔가면서 버킷에 넣다 뺐다를 반복한다.
  
+ MSD (Most Significatn Digit) 방식
  + LSD방식과 비슷하게 진행되며, 첫번째 자리부터 비교한다.
  + 두번째 자리의 정렬이 진행될 때 정렬된 위치가 맞는 위치일 경우,   
  이후 데이터와 상관없이 진행을 멈춰야 한다.
  + MSD방식은 모든 데이터에게 일반적인 과정을 기대할 수 없기 때문에,   
  (어느 데이터는 두번째에서 멈추고, 어느 데이터는 세번째에서 멈추기 때문에)
  MSD방식은 사용되지 않고, LSD방식만 사용된다.
  
### 성능 평가 (LSD 기반)
+ 삽입과 추출에서 빅오를 결정
+ T(n) = O(데이터의 길이 * 데이터의 개수 n) 
