다이나믹 프로그래밍
-----
- 컴퓨터의 연산 속도는 한계가 있고, 사용할 수 있는 메모리의 수도 한정적이기 때문에,   
연산 속도와 메모리를 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성할 필요가 있다.
- 그래서 어떤 문제들은 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있다.
- 대표적인 방법이 다이나믹 프로그래밍이다.

피보나치 수열
-----
- 점화식 : a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>, a<sub>1</sub> = 1, a<sub>2</sub> = 1
- 점화식을 토대로 아래와 같이 코드를 구성할 수 있다.
```C
def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x - 1) + fibo(x - 2)
  
print(fibo(4))  
```
- 그러나 n 이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문인다.
- O(2<sup>n</sup>) 시간이 소요된다. n 이 30이면 약 10억가량 연산을 수행해야 한다.

다이나믹 프로그래밍 적용
-----
- 재귀적으로 호출하기 때문에 반복적으로 호출하는 함수가 있다. f(6) 일때 f(3) 은 3번 호출된다.
- 다음 조건을 만족하면 다이나믹 프로그래밍을 사용할 수 있다.
  - 큰 문제를 작은 문제로 나눌 수 있다.
  - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
 
탑다운 방식 (메모이제이션)
-----
- 다이나믹 프로그래밍의 한 종류
- 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 값을 저장는 방법이므로 캐싱이라고도 한다.
### 구현
- 한 번 구한 정보를 리스트에 저장한 다음, 재귀적으로 수행하다가 같은 정보가 필요할 때는 리스트에서 가져온다.
```C
# 메모제이션할 리스트 초기화
d = [0] * 100

def fibo(x):
  if x == 1 or x == 2:
    return 1
  # 이미 계산한 적이 있으면 리스트에서 꺼내와서 반환한다.
  if d[x] != 0:
    return d[x]
  d[x] = fibo(x - 1) + fibo(x - 2)
  return d[x]
```
바텀업 방식 (DP 테이블)
-----
- 반복문을 이용하여 소스코드를 작성.
```C
d = [0] * 100

d[1] = 1
d[2] = 2
n = 99

for i in range(3, n + 1):
  d[i] = d[i - 1] + d[i - 2]
```

정리
-----
- 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법.
- 메모이제이션을 적용한 피보나치 수열의 시간 복잡도는 O(2<sup>N</sup>) 에서 O(N) 이 되었다.
### 탑다운 방식 (하향식)
- 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방식
- 큰 문제를 해결하기 위해 작은 문제를 호출한다.
- 결과 저장용 리스트를 '메모이제이션' 이라 부른다.
### 바텀업 방식 (상향식)
- 반복문을 사용하여 작성하는 방식.
- 결과 저장용 리스트를 'DP 테이블' 이라 부른다.
### 문제 해결을 위한 요령
- 주어진 문제가 다이나믹 프로그래밍 유형인지 파악해야 한다.
  - 완전 탐색 알고리즘으로 접근했을 때, 시간이 매우 오래걸리면 고려해보아야 한다.
- 단순히 재귀함수로 작성한 코드를 탑다운 방식으로 개선하는 방법도 좋은 방법이다.
- 재귀 함수의 스택 크기가 한정적이기 때문에, 재귀 함수로 작성하는 탑다운 방식 보다는 바텀업 방식으로 작성하는 것이 좋다.


